\subsection{Congruencia}
\noindent Considerando un número \(\mathbf{n}\), que diremos que se comporta como 0 en un sistema \(\mathbb{Z}_n\). De esta forma definimos una función tal que:
\[
        y - x = nk
\]
\noindent El primer miembro es congruente con cualquier múltiplo \(k\) de \(n\)\\ Esto se representa como:
\[
        \boxed{a \equiv b(\textnormal{mod}\hspace{2mm}n)}
\]
\noindent De esta forma, el rango posibles de valores, son \(\mathbf{n} = {0,...,n-1}\).\par
\noindent\fbox{{\large Propiedades}} \par
\begin{itemize}
        \item Equivalencia. Teniendo dos congruencias de este tipo:\[\begin{cases}
                              \mathbf{a \equiv b(\textnormal{\textbf{mod}}\hspace{2mm}n)}\\ \mathbf{b \equiv c(\textnormal{\textbf{mod}}\hspace{2mm}n)}\end{cases}\]\noindent Entonces: \[\boxed{\mathbf{a \equiv c(\textnormal{\textbf{mod}}\hspace{2mm}n)}}\]
        \item No existen divisiones por cero, por lo que \(ab \not \Rightarrow a = 0 \textnormal{\hspace{5mm}ó\hspace{5mm}} b = 0\)
        \item Si existe un \(\lambda \in \mathbb{Z}\) entonces:\[\begin{cases}
                              \mathbf{a \equiv b(\textnormal{\textbf{mod}}\hspace{2mm}\lambda n)}\\ \mathbf{\lambda a \equiv \lambda b(\textnormal{\textbf{mod}}\hspace{2mm}\lambda n)}\end{cases}\] \noindent Será siempre igual a\(a \equiv b(\textnormal{mod}\hspace{2mm}n)\), solo si \(\lambda \neq 0\).
        \item Sumar, restar o multiplicar dos congruencias del mismo modulo, será lo mismo que una congruencia, con los terminos \(a\) y \(b\) iguales a sumar, resta o multiplicar en ambas congruencias.
\end{itemize}
\subsection{Inversas}
\noindent Existe un modulo inverso cuando existe un único resultado a la ecuación \(\boxed{\mathbf{{a\mathrm{X} = 1}}}\) con \(\mathbf{a \in \mathbb{Z}_n}\)
\subsubsection{Calculo de Inversas}
\noindent Es un proceso muy simple.\\ Planteamos una ecuación de congruencia:
\[
        a\mathrm{X} = 1 (\textnormal{mod}\hspace{2mm}n)
\]
\noindent Si la convertimos a una \underline{ecuación diofantica}, podemos calcular el coeficiente de la identidad de \underline{Bezout} correspondiente al termino \(\mathrm{X}\).
\[
        a\mathrm{X} - n\mathrm{Y} = 1
\]
Tras resolverlo, obtendremos un \(\alpha\) que al calcular su resto respecto a \(n\), obtendremos el inverso \(\mathbf{a^-1}\).\par
\noindent Podemos expresar entonces el calculo del inverso de la siguiente forma:
\[
        \boxed{1 \equiv (\alpha (\textnormal{mod}\hspace{2mm}n))(\textnormal{mod}\hspace{2mm}n)}
\]
\noindent Si quisieramos hacerlo de una forma general entonces \(a\) y \(b\) deben de ser coprimos en \(a \equiv b(\textnormal{mod}\hspace{2mm}n)\), de forma que al obtener \(\alpha\) lo multiplicamos por \(b\):
\[
        \boxed{1 \equiv ((\alpha b) (\textnormal{mod}\hspace{2mm}n))(\textnormal{mod}\hspace{2mm}n)}
\]
\subsection{Ecuaciones en Congruencias}
\noindent Partiendo de una congruencia como la vista al principio del tema:
\[
        \boxed{a \equiv b(\textnormal{mod}\hspace{2mm}n)}
\]
\noindent Toda ecuación en congruencia se puede resolver como una ecuación diofantica.
\subsubsection{Sistemas de Ecuaciones en Congruencias, Teorema Chino del Resto}
\[
        \begin{cases}
                a_1X \equiv b_1(\textnormal{mod}\hspace{2mm}n_1)
                \\
                \vdots
                \\
                \vdots
                \\
                a_kX \equiv b_k(\textnormal{mod}\hspace{2mm}n_k)
        \end{cases}
\]
\noindent Dado un sistema como el planteado arriba, intentaremos crear una sola ecuación en congruencia que abarque a todas las que conformen el sistema.\\Solo se podrá resolver el sistema cuando todas las \(\mathbf{n_k}\) sean coprimos entre si.\\Veamos un ejemplo:
\[
        \begin{cases}
                X \equiv 1(\textnormal{mod}\hspace{2mm}4)
                \\
                X \equiv 2(\textnormal{mod}\hspace{2mm}3)
                \\
                X \equiv 3(\textnormal{mod}\hspace{2mm}5)
        \end{cases}
\]
\noindent Dado este sistema deberemos de calcular 4 terminos por cada ecuación del sistema:
\[
        \boxed{b_k = \frac{b_k}{\textnormal{mcd(}a_k\textnormal{,}n_k\textnormal{)}}}
\]
\[
        \boxed{c_k = \frac{\prod }{n_k}}
\]
\[
        \boxed{d_k = c_k^{-1} (\textnormal{mod}\hspace{2mm}n_k) \Rightarrow c_kX \equiv 1 (\textnormal{mod}\hspace{2mm}n_k)}
\]
\noindent Y el rango de la congruencia: \[
        \boxed{\mathbb{Z}_n \Rightarrow n = \prod_{k=1} n_k}
\]
\noindent De esta forma ya tendremos todos los valores que nos interesan, por lo que podremos montar nuestro sistema congruente.\\ Denominaremos \(\mathbf{X}\) a la solución general, \(\mathbf{\rho}\) a la específica y \(\mathbf{N}\) el rango de congruencia.
\[
        \boxed{X = X = \sum_{k=1} b_kd_kc_k}
\]
\[
        \boxed{X \equiv \rho (\textnormal{mod}N)}
\]
\[
        \boxed{X = \rho + N \lambda}
\]
\[
        \boxed{\rho = X(\textnormal{mod}N) + N\lambda}
\]
\noindent Como podemos ver la solución del sistema, que nos interesa se puede expresar como una ecuación como esta, y modificando el parametro \(\lambda\) podemos calcular todas las posibilidades.\\ En el ejemplo, la solución del sistema es la siguiente:
\begin{table}[h]
        \begin{tabular}{lllll}
                \multicolumn{1}{l|}{}        & \multicolumn{1}{l|}{1}  & \multicolumn{1}{l|}{2}  & \multicolumn{1}{l|}{3}  & \\ \cline{1-4}
                \multicolumn{1}{l|}{\(n_k\)} & \multicolumn{1}{l|}{4}  & \multicolumn{1}{l|}{3}  & \multicolumn{1}{l|}{5}  & \\ \cline{1-4}
                \multicolumn{1}{l|}{\(b_k\)} & \multicolumn{1}{l|}{1}  & \multicolumn{1}{l|}{2}  & \multicolumn{1}{l|}{3}  & \\ \cline{1-4}
                \multicolumn{1}{l|}{\(c_k\)} & \multicolumn{1}{l|}{15} & \multicolumn{1}{l|}{20} & \multicolumn{1}{l|}{12} & \\ \cline{1-4}
                \multicolumn{1}{l|}{\(d_k\)} & \multicolumn{1}{l|}{3}  & \multicolumn{1}{l|}{2}  & \multicolumn{1}{l|}{3}  & \\
        \end{tabular}
\end{table}
\[
        N = 3*4*5 = 60
\]
\[
        X = 15*3+ 20*2*2+12*3*3=233
\]
\[
        \boxed{\rho = 233(\textnormal{mod}60) + 60\lambda = 53 + 60\lambda}
\]
\noindent\fbox{{\large Propiedades}} \par
\noindent Aqui veremos 3 propiedades que nos ayudarán a simplificar e indicar si el sistema tiene solución:
\begin{itemize}
        \item Compatibilidad: El mcd entre 2 \(n_k\) distintos debe ser divisible entre la diferencia entre sus bases, es decir:
              \[
                      \textnormal{mcd}(n_i,\hspace{1mm}n_j) \hspace{2mm}| \hspace{2mm} (b_i-b_j)
              \]
              \[
                      \boxed{(b_i - b_j) \equiv 0 \hspace{2mm}(\textnormal{mod}\hspace{2mm}\textnormal{mcd}(n_i,n_j))}
              \]
        \item Reducción, si hay alguna ecuación cuya \(\mathbf{n}\) sea igual a otra, entonces podemos eliminar cualquiera de ellas.
        \item Expansión, cada ecuación la podemos dividir en sus factores primos, solo modificando el termino del modulo, \(n\).
\end{itemize}
\subsection{Función de Euler}
\noindent Dado una función \(\mathbf{\phi (N)}\), que nos indicará el numero de elementos en base \(N\) que tienen inverso, podemos calcular los valores en base a las siguientes indicaciones:
\begin{itemize}
        \item Si \(N \in \mathbb{P}\), es decir, \(N\) es primo: \(\boxed{\mathbf{\phi (N) = N - 1}}\)
        \item Si \(N\) es primo y está elevado a un número \(m\):\(\boxed{\mathbf{\phi (N^m) = N^{m-1}(N-1)}}\)
        \item Si \(N\) lo podemos descomponer en factores primos, entonces \(\boxed{\mathbf{\phi (N) = \phi(A)\hspace{5mm} \phi(B)}}\)
\end{itemize}
\noindent De esta forma nos quedarán dos expresiones para calcular \(\phi(N)\):
\[
        \phi(N) = n \prod^k_{n=t}(1-p_n^{-1})
\]
\[
        \boxed{\phi(N)   = \prod^k_{n=t}(p_n^{m_n-1})(p_n-1)}
\]
\noindent Siendo \(p_n\) los factores primos del número en cuestión y \(m_n\) el numero de veces que aparece ese factor primo en cuestión.
\subsection{Teoremas}
\noindent Aquí veremos dos teoremas que nos ayudarán a extraer propiedades y conclusiones para temas posteriores.
\subsubsection{Teorema de Fermat}
\noindent Sabemos por definición que dado un conjunto \(\mathbb{Z}_n\), no pueden haber elementos repetidos y que existen \(n-1\) elementos. De esta forma enunciamos:
\par \noindent Si \(\mathbf{p}\) es primo, \(\mathbf{x>0}\) y \(\mathbf{p\not |\hspace{3mm}x }\) entonces:
\[
        \boxed{x^{p-1} \equiv 1(\textnormal{mod}\hspace{2mm}p)}
\]
\noindent Si solo ocurriese que \(\mathbf{p}\) es primo y \(\mathbf{x>0}\):
\[
        \boxed{x^{p} \equiv x(\textnormal{mod}\hspace{2mm}p)}
\]
\subsubsection{Teorema de Euler}
\noindent Es una ramificación del \underline{Teorema de Fermat}, y dice que si \(x\) y \(n\) son coprimos entonces:
\[
        \boxed{x^{\phi(n)} \equiv 1(\textnormal{mod}\hspace{2mm}n)}
\]
\subsubsection{Potencias de Fermat}
\noindent Esta es una forma rápida de convertir una potencia a otra, en una congruencia específica:
\[
        x^k\hspace{1mm}\textnormal{mod}\hspace{2mm}p = x^{(p-1)\left \lfloor \frac{k}{p-1} \right \rfloor + k\hspace{1mm}\textnormal{mod}\hspace{2mm}(p-1)}=\boxed{x^{k\hspace{1mm}\textnormal{mod}\hspace{2mm}(p-1)}\textnormal{mod}\hspace{2mm}p}
\]
\subsection{Metodo MC, potencias rapidas}
\noindent Si \(K\) es un entero bastante pequeño en \(X (\textnormal{mod}\hspace{2mm}n)\) entonces podemos calcular el resultado transformando \(X\) a un número binario. \\De forma que Al transformar el numero a binario, elevamos al cuadrado entre cada cifra del numero, y los unos, son multiplicaciones por 2, y eliminamos los ceros, es decir:
\[
        \boxed{70_{10)} = 1000110_{2)} = \textnormal{M}\textnormal{C}\textnormal{C}\textnormal{C}\textnormal{C}\textnormal{M}\textnormal{C}\textnormal{M}\textnormal{C} = ((((((((((70*2)^2)^2)^2)^2)*2)^2)*2)^2)*2)}
\]
\noindent Tened en cuenta que por cada operación, hay que realizar los modulos.
\subsection{Criptografía y RSA}
\noindent El algoritmo RSA aprovecha los numeros primos y la \underline{Función de Euler} para calcular claves numéricas extremadamente grandes que facilitan la encriptación.\\ Si partimos de dos numeros \(p\) y \(q\) que son primos podemos calcular lo siguiente:
\[
        \boxed{n = pq}
\]
\noindent Siendo \(n\) el peso de mayor agrupación posible.
\[
        \boxed{\phi(n) = \phi(p)\phi(q) = (p-1)(q-1)}
\]
\[
        \boxed{e = min_{\textnormal{Primo en \(\phi(n)\)}}}
\]
\noindent Esta es la clave publica.
\[
        \boxed{d = e^{-1} (\textnormal{mod} \hspace{2mm} \phi(n))}
\]
\noindent Esta es la clave privada.\par
\noindent Para cifrar y descifrar solo tendremos que hacer lo siguiente:
\[
        \boxed{\textnormal{Cifrado}\Rightarrow  Y \equiv X^e (\textnormal{mod}\hspace{2mm}n)}
\]
\[
        \boxed{\textnormal{Descrifrado}\Rightarrow X \equiv Y^d (\textnormal{mod}\hspace{2mm}n)}
\]